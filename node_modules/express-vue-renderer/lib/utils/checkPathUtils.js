'use strict';

var fs = require('fs');
var path = require('path');
var Defaults = require('../models').Defaults;
var paramCase = require('param-case');
var stringHash = require('string-hash');

function getParamCasePath(path) {
    // example /Users/foo/code/test/components/componentFile.vue
    var pathArr = path.split('/');

    // gets the last element componentFile.foo
    var fileName = pathArr[pathArr.length - 1];

    // gets the actual file name componentFile
    var newFileName = fileName.split('.vue')[0];

    // paramcases componentFile to component-file and adds. .vue at the end
    var paramCaseFile = paramCase(newFileName) + '.vue';

    // replaces last element of the array, with the param'd version of the filename
    pathArr[pathArr.length - 1] = paramCaseFile;

    // returns joined pathname with slashes
    return pathArr.join('/').toString();
}

function getCorrectPathForFile(filePath, type, defaults, Cache) {
    return new Promise(function (resolve, reject) {
        var resolvedPath = path.join(filePath);
        var cacheKey = stringHash('resolvedPath-' + resolvedPath);
        var cachedResolvedPath = Cache.get(cacheKey);
        if (cachedResolvedPath) {
            resolve(cachedResolvedPath);
        } else {
            fs.access(resolvedPath, (fs.constants || fs).F_OK | (fs.constants || fs).R_OK, function (error) {
                if (error) {
                    if (error.code === 'ENOENT') {
                        fs.access(getParamCasePath(resolvedPath), (fs.constants || fs).F_OK | (fs.constants || fs).R_OK, function (err) {
                            var paramCasePath = '';
                            if (err) {
                                reject(new Error('Could not find ' + type + ' file at ' + (paramCasePath.length > 0 ? paramCasePath : resolvedPath)));
                            } else {
                                paramCasePath = getParamCasePath(resolvedPath);
                                resolve({ path: paramCasePath, type: type });
                            }
                        });
                    }
                } else {
                    var pathObject = { path: resolvedPath, type: type };
                    Cache.set(cacheKey, pathObject);

                    resolve(pathObject);
                }
            });
        }
    });
}

module.exports.getParamCasePath = getParamCasePath;
module.exports.getCorrectPathForFile = getCorrectPathForFile;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9jaGVja1BhdGhVdGlscy5qcyJdLCJuYW1lcyI6WyJmcyIsInJlcXVpcmUiLCJwYXRoIiwiRGVmYXVsdHMiLCJwYXJhbUNhc2UiLCJzdHJpbmdIYXNoIiwiZ2V0UGFyYW1DYXNlUGF0aCIsInBhdGhBcnIiLCJzcGxpdCIsImZpbGVOYW1lIiwibGVuZ3RoIiwibmV3RmlsZU5hbWUiLCJwYXJhbUNhc2VGaWxlIiwiam9pbiIsInRvU3RyaW5nIiwiZ2V0Q29ycmVjdFBhdGhGb3JGaWxlIiwiZmlsZVBhdGgiLCJ0eXBlIiwiZGVmYXVsdHMiLCJDYWNoZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwicmVzb2x2ZWRQYXRoIiwiY2FjaGVLZXkiLCJjYWNoZWRSZXNvbHZlZFBhdGgiLCJnZXQiLCJhY2Nlc3MiLCJjb25zdGFudHMiLCJGX09LIiwiUl9PSyIsImVycm9yIiwiY29kZSIsImVyciIsInBhcmFtQ2FzZVBhdGgiLCJFcnJvciIsInBhdGhPYmplY3QiLCJzZXQiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOztBQUNBLElBQU1BLEtBQUtDLFFBQVEsSUFBUixDQUFYO0FBQ0EsSUFBTUMsT0FBT0QsUUFBUSxNQUFSLENBQWI7QUFDQSxJQUFNRSxXQUFXRixRQUFRLFdBQVIsRUFBcUJFLFFBQXRDO0FBQ0EsSUFBTUMsWUFBWUgsUUFBUSxZQUFSLENBQWxCO0FBQ0EsSUFBTUksYUFBYUosUUFBUSxhQUFSLENBQW5COztBQUVBLFNBQVNLLGdCQUFULENBQTBCSixJQUExQixFQUFnRDtBQUM1QztBQUNBLFFBQUlLLFVBQVVMLEtBQUtNLEtBQUwsQ0FBVyxHQUFYLENBQWQ7O0FBRUE7QUFDQSxRQUFJQyxXQUFXRixRQUFRQSxRQUFRRyxNQUFSLEdBQWlCLENBQXpCLENBQWY7O0FBRUE7QUFDQSxRQUFJQyxjQUFjRixTQUFTRCxLQUFULENBQWUsTUFBZixFQUF1QixDQUF2QixDQUFsQjs7QUFFQTtBQUNBLFFBQUlJLGdCQUFnQlIsVUFBVU8sV0FBVixJQUF5QixNQUE3Qzs7QUFFQTtBQUNBSixZQUFRQSxRQUFRRyxNQUFSLEdBQWlCLENBQXpCLElBQThCRSxhQUE5Qjs7QUFFQTtBQUNBLFdBQU9MLFFBQVFNLElBQVIsQ0FBYSxHQUFiLEVBQWtCQyxRQUFsQixFQUFQO0FBQ0g7O0FBR0QsU0FBU0MscUJBQVQsQ0FBK0JDLFFBQS9CLEVBQWlEQyxJQUFqRCxFQUErREMsUUFBL0QsRUFBbUZDLEtBQW5GLEVBQWtHO0FBQzlGLFdBQU8sSUFBSUMsT0FBSixDQUFZLFVBQUNDLE9BQUQsRUFBVUMsTUFBVixFQUFxQjtBQUNwQyxZQUFNQyxlQUFlckIsS0FBS1csSUFBTCxDQUFVRyxRQUFWLENBQXJCO0FBQ0EsWUFBTVEsV0FBV25CLFdBQVcsa0JBQWtCa0IsWUFBN0IsQ0FBakI7QUFDQSxZQUFNRSxxQkFBcUJOLE1BQU1PLEdBQU4sQ0FBVUYsUUFBVixDQUEzQjtBQUNBLFlBQUlDLGtCQUFKLEVBQXdCO0FBQ3BCSixvQkFBUUksa0JBQVI7QUFDSCxTQUZELE1BRU87QUFDSHpCLGVBQUcyQixNQUFILENBQVVKLFlBQVYsRUFBd0IsQ0FBQ3ZCLEdBQUc0QixTQUFILElBQWdCNUIsRUFBakIsRUFBcUI2QixJQUFyQixHQUE0QixDQUFDN0IsR0FBRzRCLFNBQUgsSUFBZ0I1QixFQUFqQixFQUFxQjhCLElBQXpFLEVBQStFLFVBQUNDLEtBQUQsRUFBVztBQUN0RixvQkFBSUEsS0FBSixFQUFXO0FBQ1Asd0JBQUlBLE1BQU1DLElBQU4sS0FBZSxRQUFuQixFQUE2QjtBQUN6QmhDLDJCQUFHMkIsTUFBSCxDQUFVckIsaUJBQWlCaUIsWUFBakIsQ0FBVixFQUEwQyxDQUFDdkIsR0FBRzRCLFNBQUgsSUFBZ0I1QixFQUFqQixFQUFxQjZCLElBQXJCLEdBQTRCLENBQUM3QixHQUFHNEIsU0FBSCxJQUFnQjVCLEVBQWpCLEVBQXFCOEIsSUFBM0YsRUFBaUcsVUFBQ0csR0FBRCxFQUFTO0FBQ3RHLGdDQUFJQyxnQkFBZ0IsRUFBcEI7QUFDQSxnQ0FBSUQsR0FBSixFQUFTO0FBQ0xYLHVDQUFPLElBQUlhLEtBQUoscUJBQTRCbEIsSUFBNUIsa0JBQTRDaUIsY0FBY3hCLE1BQWQsR0FBdUIsQ0FBdkIsR0FBMkJ3QixhQUEzQixHQUEyQ1gsWUFBdkYsRUFBUDtBQUNILDZCQUZELE1BRU87QUFDSFcsZ0RBQWdCNUIsaUJBQWlCaUIsWUFBakIsQ0FBaEI7QUFDQUYsd0NBQVEsRUFBQ25CLE1BQU1nQyxhQUFQLEVBQXNCakIsTUFBTUEsSUFBNUIsRUFBUjtBQUNIO0FBQ0oseUJBUkQ7QUFTSDtBQUNKLGlCQVpELE1BWU87QUFDSCx3QkFBTW1CLGFBQWEsRUFBQ2xDLE1BQU1xQixZQUFQLEVBQXFCTixNQUFNQSxJQUEzQixFQUFuQjtBQUNBRSwwQkFBTWtCLEdBQU4sQ0FBVWIsUUFBVixFQUFvQlksVUFBcEI7O0FBRUFmLDRCQUFRZSxVQUFSO0FBQ0g7QUFDSixhQW5CRDtBQW9CSDtBQUNKLEtBNUJNLENBQVA7QUE2Qkg7O0FBRURFLE9BQU9DLE9BQVAsQ0FBZWpDLGdCQUFmLEdBQWtDQSxnQkFBbEM7QUFDQWdDLE9BQU9DLE9BQVAsQ0FBZXhCLHFCQUFmLEdBQXVDQSxxQkFBdkMiLCJmaWxlIjoiY2hlY2tQYXRoVXRpbHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IERlZmF1bHRzID0gcmVxdWlyZSgnLi4vbW9kZWxzJykuRGVmYXVsdHM7XG5jb25zdCBwYXJhbUNhc2UgPSByZXF1aXJlKCdwYXJhbS1jYXNlJyk7XG5jb25zdCBzdHJpbmdIYXNoID0gcmVxdWlyZSgnc3RyaW5nLWhhc2gnKTtcblxuZnVuY3Rpb24gZ2V0UGFyYW1DYXNlUGF0aChwYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIC8vIGV4YW1wbGUgL1VzZXJzL2Zvby9jb2RlL3Rlc3QvY29tcG9uZW50cy9jb21wb25lbnRGaWxlLnZ1ZVxuICAgIGxldCBwYXRoQXJyID0gcGF0aC5zcGxpdCgnLycpO1xuXG4gICAgLy8gZ2V0cyB0aGUgbGFzdCBlbGVtZW50IGNvbXBvbmVudEZpbGUuZm9vXG4gICAgbGV0IGZpbGVOYW1lID0gcGF0aEFycltwYXRoQXJyLmxlbmd0aCAtIDFdO1xuXG4gICAgLy8gZ2V0cyB0aGUgYWN0dWFsIGZpbGUgbmFtZSBjb21wb25lbnRGaWxlXG4gICAgbGV0IG5ld0ZpbGVOYW1lID0gZmlsZU5hbWUuc3BsaXQoJy52dWUnKVswXTtcblxuICAgIC8vIHBhcmFtY2FzZXMgY29tcG9uZW50RmlsZSB0byBjb21wb25lbnQtZmlsZSBhbmQgYWRkcy4gLnZ1ZSBhdCB0aGUgZW5kXG4gICAgbGV0IHBhcmFtQ2FzZUZpbGUgPSBwYXJhbUNhc2UobmV3RmlsZU5hbWUpICsgJy52dWUnO1xuXG4gICAgLy8gcmVwbGFjZXMgbGFzdCBlbGVtZW50IG9mIHRoZSBhcnJheSwgd2l0aCB0aGUgcGFyYW0nZCB2ZXJzaW9uIG9mIHRoZSBmaWxlbmFtZVxuICAgIHBhdGhBcnJbcGF0aEFyci5sZW5ndGggLSAxXSA9IHBhcmFtQ2FzZUZpbGU7XG5cbiAgICAvLyByZXR1cm5zIGpvaW5lZCBwYXRobmFtZSB3aXRoIHNsYXNoZXNcbiAgICByZXR1cm4gcGF0aEFyci5qb2luKCcvJykudG9TdHJpbmcoKTtcbn1cblxuXG5mdW5jdGlvbiBnZXRDb3JyZWN0UGF0aEZvckZpbGUoZmlsZVBhdGg6IHN0cmluZywgdHlwZTogc3RyaW5nLCBkZWZhdWx0czogRGVmYXVsdHMsIENhY2hlOiBPYmplY3QpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCByZXNvbHZlZFBhdGggPSBwYXRoLmpvaW4oZmlsZVBhdGgpO1xuICAgICAgICBjb25zdCBjYWNoZUtleSA9IHN0cmluZ0hhc2goJ3Jlc29sdmVkUGF0aC0nICsgcmVzb2x2ZWRQYXRoKTtcbiAgICAgICAgY29uc3QgY2FjaGVkUmVzb2x2ZWRQYXRoID0gQ2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICAgICAgaWYgKGNhY2hlZFJlc29sdmVkUGF0aCkge1xuICAgICAgICAgICAgcmVzb2x2ZShjYWNoZWRSZXNvbHZlZFBhdGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnMuYWNjZXNzKHJlc29sdmVkUGF0aCwgKGZzLmNvbnN0YW50cyB8fCBmcykuRl9PSyB8IChmcy5jb25zdGFudHMgfHwgZnMpLlJfT0ssIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZzLmFjY2VzcyhnZXRQYXJhbUNhc2VQYXRoKHJlc29sdmVkUGF0aCksIChmcy5jb25zdGFudHMgfHwgZnMpLkZfT0sgfCAoZnMuY29uc3RhbnRzIHx8IGZzKS5SX09LLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBhcmFtQ2FzZVBhdGggPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kICR7dHlwZX0gZmlsZSBhdCAke3BhcmFtQ2FzZVBhdGgubGVuZ3RoID4gMCA/IHBhcmFtQ2FzZVBhdGggOiByZXNvbHZlZFBhdGh9YCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtQ2FzZVBhdGggPSBnZXRQYXJhbUNhc2VQYXRoKHJlc29sdmVkUGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoe3BhdGg6IHBhcmFtQ2FzZVBhdGgsIHR5cGU6IHR5cGV9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhdGhPYmplY3QgPSB7cGF0aDogcmVzb2x2ZWRQYXRoLCB0eXBlOiB0eXBlfTtcbiAgICAgICAgICAgICAgICAgICAgQ2FjaGUuc2V0KGNhY2hlS2V5LCBwYXRoT2JqZWN0KTtcblxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHBhdGhPYmplY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzLmdldFBhcmFtQ2FzZVBhdGggPSBnZXRQYXJhbUNhc2VQYXRoO1xubW9kdWxlLmV4cG9ydHMuZ2V0Q29ycmVjdFBhdGhGb3JGaWxlID0gZ2V0Q29ycmVjdFBhdGhGb3JGaWxlO1xuIl19